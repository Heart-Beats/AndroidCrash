if (module_group == null || module_name == null) {
    throw new IllegalStateException("Must provide module_group and module_name!")
}

apply plugin: 'tech.medivh.plugin.publisher'

apply plugin: 'signing'

signing {
    useGpgCmd() //使用 gpg-agent
//    sign publishing.publications
}

medivhPublisher {
    def moduleGroup = module_group
    def moduleName = module_name
    def publishVersion = rootProject.ext.getPublishVersion()

    groupId moduleGroup
    artifactId moduleName
    version publishVersion

    pom {
        name = moduleName
        description = "Android 开发捕获崩溃异常信息的工具库"
        url = "https://github.com/Heart-Beats/AndroidCrash"
        licenses {
            license {
                name = "The Apache License, Version 2.0"
                url = "https://github.com/Heart-Beats/AndroidCrash/blob/main/LICENSE.md"
                distribution = "http://www.apache.org/licenses/LICENSE-2.0.txt"
            }
        }
        developers {
            developer {
                id = "Heart-Beats"
                name = "Heart-Beats"
                url = "https://github.com/Heart-Beats"
            }
        }
        scm {
            url = "https://github.com/Heart-Beats/AndroidCrash"
            connection = "scm:git:git://github.com/Heart-Beats/AndroidCrash.git"
            developerConnection = "scm:git:ssh://git@github.com/Heart-Beats/AndroidCrash.git"
        }

        //    一个稍微有点 hacky 的修复，以便您的 POM 将包含您的库所构建的任何传递依赖项
        withXml {
            def dependenciesNode = asNode().appendNode('dependencies')

            // 该依赖包括 implementation 和 api 依赖
            def implementationDependencies = project.configurations.implementation.allDependencies
            def apiDependencies = project.configurations.api.allDependencies
            def compileOnlyDependencies = project.configurations.compileOnly.allDependencies

            def realImplementationDependencies = implementationDependencies - apiDependencies

            // 生成 implementation 节点依赖
            realImplementationDependencies.each {
                createDependencyNode(dependenciesNode, 'runtime', it.group, it.name, it.version)
            }

            // 生成 api 节点依赖
            apiDependencies.each {
                createDependencyNode(dependenciesNode, 'compile', it.group, it.name, it.version)
            }

            // 生成 compileOnly 节点依赖
            compileOnlyDependencies.each {
                createDependencyNode(dependenciesNode, 'provided', it.group, it.name, it.version)
            }
        }
    }
}


/**
 *
 * 设置 pom 文件的 dependencies节点
 *      别的项目依赖该 pom  文件时，会从 dependencies节点下根据 scope 来选择是否下载依赖库
 *
 *  scope 有如下取值：
 *      compile：      如果没有指定 scope 标签，maven 默认为这个范围。编译依赖关系在所有 classpath 中都可用。此外，这些依赖关系被传播到依赖项目
 *      provided：    与 compile 类似，但是表示您希望 jdk 或容器在运行时提供它(即系统类库)。它只适用于编译和测试 classpath，不可传递
 *      runtime：    此范围表示编译不需要依赖关系，而是用于执行。它是在运行时和测试 classpath，但不是编译 classpath
 *      test：      此范围表示正常使用应用程序不需要依赖关系，仅适用于测试编译和执行阶段。它不是传递的。
 *      system：   此范围与 provided 类似，除了您必须提供明确包含它的 jar。该 artifact 始终可用，并且不是在仓库中查找。
 *
 *      常用类比总结：
 *
 *       maven 中     |    gradle 中
 *       ---------------------------
 *        compile    |       api
 *       provided    |   compileOnly
 *       runtime     | implementation
 *
 */
private static def createDependencyNode(root, scope, groupId, artifactId, version) {
    def dependencyNode = root.appendNode('dependency')
    dependencyNode.appendNode('groupId', groupId)
    dependencyNode.appendNode('artifactId', artifactId)
    dependencyNode.appendNode('version', version)
    dependencyNode.appendNode('scope', scope)
}